(package eth/re (create-app-state app-state-subscribe app-state-notify!
                 app-state-set! app-state-update!
                 element-spec? create-element create-component
                 mount)

(import eth/core (..))
(import react)
(import react-dom)

; app state

(def create-app-state (initial-state)
  {state (or initial-state {})
   listenners []
   __eth-re-app-state true})

(def app-state? (s)
  (and (== (type s) :object) (get :__eth-re-app-state s)))

(def app-state-subscribe (app-state f)
  (assoc :listenners (append f app-state.listenners) app-state))

(def app-state-notify! (app-state)
  (for-each (fn (l) (l app-state)) app-state.listenners))

(def app-state-set! (app-state path value)
  (set app-state.state (set-in path value app-state.state))
  (app-state-notify! app-state))

(def app-state-update! (app-state path updater)
  (set app-state.state (update-in path value app-state.state))
  (app-state-notify! app-state))

; react

(def element-spec? (e)
  (and
    (== (type e) :array)
    (> (len e) 0)))

(def create-element (children)
  (assert (element-spec? children) (str
    "re: create-element: 'children' must be an array with at least one element "
    "(html tag or component), got: "
    (to-json children)))
  (let ((tag-or-component (get 0 children))
        (given-props (get 1 children))
        (props (if (of-type? :object given-props) given-props {}))
        (children-start (if (of-type? :object given-props) 2 1))
        (children (map
          (fn (c) (if (of-type? :array c) (create-element c) c))
          (children.slice children-start))))
    (apply react.create-element (concat [tag-or-component props] children))))

(def create-component (definition)
  (assert (of-type? :function definition.render) "re: create-component: component needs a render method")
  (React.createClass (merge definition {
    :display-name (or definition.displayName definition.name "Component")
    :get-initial-state (if (of-type? "function" definition.initial-state)
      definition.initial-state
      (fn ()
        (or definition.initial-state {})))
    :render (fn ()
      (create-element (definition.render @props.app-state @props @state @)))})))

(def mount (root-el mount-point app-state)
  (assert (app-state? app-state) "re: mount: called without a valid 'app-state'")
  (let ((render-root (fn () (react-dom.render rool-el mount-point))))
    (app-state-subscribe app-state render-root)
    (render-root)))

)
